#include <vector>

/*

15.07.2025
15:57

Задача: Есть абстрактная пирамимда числе. Первый всегда 0, а далее образуется следующая строчка по такому алгоритму
0 меняется 01, а 10. И этих строчек может быть бесконечно много. Подается номер строки n и номер элемента k.
Нужно вернуть элемент, который находитс на этом месте.

Идея: Если k меньше половины строки, то символ, который находится в n-ой строке на позиции k, также есть в строке
n-1 на позиции k. Если k больше половины, то результат это инвертируемый символ в строке n-1 на позиции k - mid.

Закономерность: Первая часть сгенерированной строчки это вся предыдущая часть строчки, а вторая часть строчки
это инвертированная первая часть строчки.

P.S. Интересный навык быстро видеть закономерности.
P.S. 21:46 Думаю, что при следующем повторении задачи я забуду и закономерность и идею.
P.S. Я все еще не вижу глубину рекурсии.

*/

class Solution
{
public:
    int kthGrammar(int n, int k)
    {
        if (n == 1) return 0;
        
        int mid = 1 << (n - 2);
        if (k <= mid) return kthGrammar(n - 1, k);
        else return 1 - kthGrammar(n - 1, k - mid);
    }
};