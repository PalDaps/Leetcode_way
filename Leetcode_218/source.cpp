#include <iostream>
#include <vector>
#include <stack>

/*

29.08.2025
9:34

Задача: Дан вектор скайбоксов, где первый элемент - левая граница, второй элемент - правая граница, третий элемент вторая граница. Таких скайбоксов
может быть много. Но все они отсортированы по non-decreasing order относительно левой границы. Нужно вернуть вектор точек скайбоксов.
Повторять точки нельзя.

Идея:

Решение:

P.S. 22:39 Сложно.

Брейншторм:
Задача сложная, но в целом понятная. Как решать?
[[0,2,3],[2,5,3]]
Первая точка всегда образовывается первым строением.
[0, 3]

Дальше переходим ко второму строению. Возможны три варианта:
1. Высота больше предыдущего строения.
- Значит фиксируем новую точку. Исходя из данных о новом строении
2. Высота такая же как в предыдущем строении.
- Высота такая же как предыдущем строении. Значит не добавляем новую точку в результирующий массив.
3. Высота меньше предыдущего строения.
- Высота меньше предыдущего строения. Значит фиксируем новую точку.

Самый сложный момент с пересечениями строений. Возможны следующие варианты:
1. Следущий скайбокс не пересекает другой - значит смотрим был ли такой скайбокс который пересекал правую границу текущего.
То есть для каждого скайбокса нужно держать данные о том, какая была прошлая точка и длины самых высоких скайбоксов, которые в теории могу пересекаться.

Еще важное уточнение, что все скайбоксы сортированы по non-decreasing order

*/

class Solution 
{
public:
    std::vector<std::vector<int>> getSkyline(std::vector<std::vector<int>>& buildings)
    {
        std::vector<std::vector<int>> Result;
        if (buildings.size() == 0) return Result;
        std::stack<int> MostRights;
        for (int i = 0; i < buildings.size(); i++)
        {
            int Left = buildings[i][0];
            int Right = buildings[i][1];
            int Height = buildings[i][2];


            int x = Left;
            int y = Height;

            MostRights.push(Right);
            Result.push_back({ x, y });
        }

    }

    return Result;
};