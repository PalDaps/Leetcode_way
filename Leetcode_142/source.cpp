#include <iostream> 

/*

18.06.2025
10:48

«адача: ƒан св€занный список. Ќужно вернуть индекс элемента в св€знном списке с которого начинаетс€ цикл.

»де€: —начала пон€ть зациклен ли список по методу двух указателей. ƒалее шагать head и указтелем в цикле пока они не встрет€тс€.

–ешение: ѕусть x - расто€ние от head до начала цикла
			   y - рассто€ние от начала цикла до места встречи
			   c - количество нод в цикле или длина цикла
			   n - количество циклов
“огда, имеем, что медленный указатель до места встречи пройдет рассто€ние x + y. Ѕыстрый указатель очевидно пройдет 2(x+y), так как он в 2
два раза быстрее, чем медленный. Ќо чему равно 2(x+y) - (x+y) = ? Ёто соотношение кратно длине цикла. ѕолучаетс€, что x + y = n*C, получаетс€
что x = n*C - y. »з этого уравнени€ можно сделать вывод, если мы пойдем от head, то окажемс€ в начале цикла через x шагов. — другой стороны,
если идем от места встречи в цикле, то в начале цикла окажемс€ тоже через x шагов или через n*C - y.  ороче, просто доказали, что
от head до начала цикла такое рассто€ние как от места встречи до начала цикла.

P.S.
10:48 «адача нетривиальна€. 

P.S.
”шло примерно 4 часа времени на понимание данной задачи. Ќо внимание и концентранци€, конечно, у мен€ ппц раздробленные.

P.S.
26.07.2025
18:03
¬оу, ктса, с кайфом решил задачу. Ќо не понимаю все еще почему из x + y = n*C следует, что от pHead до 
начала цикла такое же рассто€ние как от pMeeting до начала цикла?

*/


 struct ListNode 
 {
        int val;
        ListNode *next;
        ListNode(int x) : val(x), next(NULL) {}
 };
 
class Solution 
{
public:
    ListNode* detectCycle(ListNode* head)
    {
        ListNode* pSlow = head;
        ListNode* pFast = head;
        while (pFast && pFast->next)
        {
            pSlow = pSlow->next;
            pFast = pFast->next->next;
            if (pFast == pSlow) break;
        }
        if (pFast == nullptr || pFast->next == nullptr) return nullptr;
        while (head != pSlow)
        {
            pSlow = pSlow->next;
            head = head->next;
        }
        return head;
    }
};

int main()
{
	return 0;
}

/*

Notes of repeats

// 03.07.2025 - Failure
// 11:10      - I understood idea, but i couldnt proof this raiot x + y = n*C
// P.S.       - Task +, Idea +, Solution -, Corner cases -

// 26.07.2025 - Success
// 18:05      - 
// P.S.       - Task +, Idea +, Solution +, Corner cases +

*/