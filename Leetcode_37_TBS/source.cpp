#include <iostream>
#include <vector>

/*

03.08.2025
15:52

Задача: Дана доска судоку. Нужно ее решить.

Идея: Пробуем ставить число от '1' до '9' в ячейку. Если получилось, то вставляем дальше. Если нет, то 
откатываемся назад и пробуем другое число.

Решение:
Функция CheckPosition(Board, i, j, val) - проверяем можем ли вставить число в позицию (i;j)
- Если в строке уже есть такое число, то не можем
- Если в столбце есть такое число, то не можем
- Если в квадрате 3 на 3 есть такое число, то не можем
- Иначе можем
Функция Solve(Board, i, j) - Пробуем заполнить доску числами
- Базовый случай, если дошли до конца, то доска заполнена
- Если дошли до конца строки, то идем на следующую строчку
- Если в ячейку уже стоит число, то идем в следующую ячейку
(Все это для рекурсии, чтобы она правильно обрабатывала базове случаи)
- Пробуем вставлять число от '1' до '9' в ячейку. Если получилось, то вставляем дальше, если нет, 
откатываемся назад и пробуем другое число.

P.S. 16:10 Вроде как понятно. Или мне непотяно, что мне непонятно.

*/


class Solution 
{
public:
    bool CheckPosition(std::vector<std::vector<char>>& Board, int i, int j, char Val)
    {
        // Ищем для любой позиции (i;j) начало квадрата 3*3, куда входит (i;j)
        int StartBoxRow = i - i % 3;
        int StartBoxCol = j - j % 3;

        // Проверяем есть ли в строке такое значение, которые мы хотим вставить
        for (int x = 0; x < 9; x++) if (Board[x][j] == Val) return false;
        // Проверяем есть ли в столбце такое значение, которые мы хотим вставить
        for (int y = 0; y < 9; y++) if (Board[i][y] == Val) return false;

        // Проверяем квадрат 3*3 на наличие значения, которое мы хотим вставить
        for (int x = 0; x < 3; x++)
        {
            for (int y = 0; y < 3; y++)
            {
                if (Board[StartBoxRow + x][StartBoxCol + y] == Val) return false;
            }
        }
        return true;
    }

    bool Solve(std::vector<std::vector<char>>& Board, int i, int j)
    {
        // Базовый случай, если рекурсия до конца таблицы
        if (i == 9) return true;
        // Если дошли до конца строчки(последний столбец), то идем в след. строку
        if (j == 9) return Solve(Board, i + 1, 0);
        // Если ячейка уже заполнена, то идем в следующую ячейку
        if (Board[i][j] != '.') return Solve(Board, i, j + 1);

        // Перебор всех возможных значений, который можно вставить в ячейку
        for (char c = '1'; c <= '9'; c++)
        {
            // Можем ли поставить цифру в позицию (i;j)
            if (CheckPosition(Board, i, j, c))
            {
                // Если можем, то ставим
                Board[i][j] = c;
                // И с учетом этой позиции, выставляем другие цифры в следующих ячейках
                if (Solve(Board, i, j + 1)) return true;
                // Если на какому-то уровне рекурсии нельзя поставить цифру, пробуем другую
                // AWESOME
                // Backtracking
                Board[i][j] = '.';
            }
        }

        return false;
    }
    void solveSudoku(std::vector<std::vector<char>>& board)
    {
        Solve(board, 0, 0);
    }
};

/*

Notes of repeats

// 09.08.2025 - Faile
// 12:03      - Poor concentration, poor memory, clouded consciousness
// P.S.       - Task +, Idea +/-, Solution -, Corner cases -

*/