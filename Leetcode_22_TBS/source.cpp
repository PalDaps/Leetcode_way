#include <iostream>
#include <vector>
#include <string>

/*

10.08.2025
00:24

Задача: Дано число n - это количество пар скобок. Нужно вернуть все комбинации этих пар скобок. То есть для n == 3. Будет так:
()()(), ((())), (())(), ()(()), (()()).

Идея: Смотреть на строку слева направа и учитывать количество открывающихся и закрывающихся скобок. Учесть все частные случаи.

Решение: 
- Если количество '(' и ')' равно нулю, то нашли комбинацию, которую можно добавить в результирующий массив
- Если количетсво '(' и ')' равно, то добавляем '('
- Если количество '(' равно нулю, то добавляем ')'
- Если количество ')' равно нулю, то доавбляем '('
- Иначе, добавляем и '(', и ')'

P.S. 0:58 На самом много чего можно выкинуть из этого решения, чтобы получилось меньше кода только для решения этой задачи.
Но вот такой код с лишними проверками мне нравится больше, потому что он логичнее и более гибкий, чем узконаправленный hard-сode.

Брейншторм:

Скорее всего, есть какая-то закономерность в создании всех типов скобок.
Так как даются сразу пары.

Это рекурсия. Первый случай, включают все остальные.
n = 1.
()

n = 2.
()() - Типо первый случай.
(()) - Что-то новое
А все?

n = 3.
()()() - Типо первый случай.
((())) - Типо второй случай.

(()()) - Что-то новое.
(())() - Что-то новое.
()(()) - Что-то новое.

n = 4.
Первый случай.
Второй случай.
Третий случай.

И что-то новое появилось, но я не могу сходу создать этот случай.
()()()()

Законмерность не вижу :(
Если распишу 4 случай, то все равно закономерность не пойму.

dp + BackTracking -> Что из этого следует?

*/

class Solution
{
public:
    ///< Curr можно передавать не по ссылке, так как будем закидывать обновленную версию
    void Solve(std::string Curr, std::vector<std::string>& Result, int Open, int Close)
    {
        // Если закончились открывающиеся и закрывающиеся скобки, то найдена комбинация
        if (!Open && !Close)
        {
            Result.push_back(Curr);
            return;
        }

        // Если открывающихся и закрывающихся скобок поровну, то ставим только '('
        if (Open == Close)
        {
            std::string This = Curr;
            This.push_back('(');
            Solve(This, Result, Open - 1, Close);
        }
        // Если закончились '(', то ставим ')'
        else if (!Open)
        {
            std::string This = Curr;
            This.push_back(')');
            Solve(This, Result, Open, Close - 1);
        }
        // Если закончились ')', то ставим '('
        else if (!Close)
        {
            std::string This = Curr;
            This.push_back('(');
            Solve(This, Result, Open - 1, Close);
        }
        // В любом другом случае пробуем ставить '(' и ')'
        else
        {
            std::string ThisFirst = Curr;
            std::string ThisSecond = Curr;
            ThisFirst.push_back('(');
            ThisSecond.push_back(')');
            Solve(ThisFirst, Result, Open - 1, Close);
            Solve(ThisSecond, Result, Open, Close - 1);
        }

    }
    std::vector<std::string> generateParenthesis(int n)
    {
        ///< Счетчик открытых и закрытых скобок, чтобы отслеживать частные случая
        int Open = n;
        int Close = n;
        std::vector<std::string> Result;
        std::string Curr;
        Solve(Curr, Result, Open, Close);
        return Result;
    }
};


/*

Notes of repeats

// 12.08.2025 - Fail
// 21:22      - Step back, because i need chill
// P.S.       - Task +, Idea +, Solution -, Corner cases +

*/